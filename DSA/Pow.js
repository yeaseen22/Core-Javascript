/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function (x, n) {
    if (n === 0) return 1.0;
    if (x === 0) return 0.0;

    if (n < 0) {
        x = 1 / x;
        n = -n;
    }

    let ans = 1;
    while (n > 0) {
        // If n is odd, multiply ans by x
        if (n % 2 === 1) {
            ans *= x;
        }
        // Square x and reduce n by half
        x *= x;
        n = Math.floor(n / 2);
    }

    return ans;
};

/**
 * 
 * ### কিভাবে `myPow` কাজ করে

ফাংশনটি xx কে nn শক্তিতে (যেমন, xnxn) তুলতে চায়। এটি মূলত দ্রুত প্রক্রিয়া করার জন্য **Exponentiation by Squaring** বা **ফাস্ট পাওয়ারিং** নামের একটি পদ্ধতি ব্যবহার করে, যা O(log⁡n)O(logn) সময়ে কাজ করে। এটি বিশেষ করে বড় এক্সপোনেন্টের ক্ষেত্রে সময় সাশ্রয়ী।

### লজিক ব্যাখ্যা

১. **নেগেটিভ এক্সপোনেন্ট চেক করা:** যদি nn নেগেটিভ হয়, তাহলে xn=1/x−nxn=1/x−n এর সমান। সুতরাং, যদি nn নেগেটিভ হয়, তখন আমরা xx-কে `1/x` এ রূপান্তর করি এবং nn-কে পজিটিভ করে দেই।

২. **Exponentiation by Squaring পদ্ধতি:**

- nn জোড় সংখ্যা হলে, xn=(xn/2)2 অর্থাৎ আমরা x-কে স্কয়ার করে n-কে অর্ধেক করি।
    
    xn=(xn/2)2
    
    x
    
    n
    
- nn বিজোড় হলে, আমরা একটি অতিরিক্ত x ধরে রাখি ans-এর মধ্যে এবং পরে xn=x×xn−1-এর রূপে কাজ করি।
    
    x
    
    ans
    
    xn=x×xn−1
    
- এইভাবে প্রতি ধাপে n অর্ধেকে নেমে আসে, ফলে এটি O(logn) সময়ে কাজ করে।
    
    n
    
    O(log⁡n)
    

### উদাহরণ: `myPow(2, -3)` এর Dry Run

আমাদের ইনপুট: x=2x=2, n=−3n=−3। আমাদের লক্ষ্য হল 2−3=1/23=0.1252−3=1/23=0.125।

1. **নেগেটিভ চেক:** যেহেতু n=−3n=−3 নেগেটিভ, আমরা:
    - `x = 1 / 2 = 0.5` হিসাবে পরিণত করি।
    - `n = -(-3) = 3` অর্থাৎ n-কে পজিটিভ করি।
        
        n
        
    
    এখন x=0.5x=0.5 এবং n=3n=3।
    
2. **লুপ শুরু:** `ans = 1`, n=3n=3।
    - প্রথমে, n বিজোড় (৩), সুতরাং `ans *= x` অর্থাৎ `ans = 1 * 0.5 = 0.5`।
        
        n
        
    - এরপর `x *= x` অর্থাৎ x=0.5×0.5=0.25।
        
        x=0.5×0.5=0.25
        
    - nn-কে অর্ধেক করি: n=3//2=1।
        
        n=3//2=1
        
3. **দ্বিতীয় ধাপ:** n=1n=1, এখনো বিজোড়।
    - আবার `ans *= x` অর্থাৎ `ans = 0.5 * 0.25 = 0.125`।
    - `x *= x` অর্থাৎ x=0.25×0.25=0.0625।
        
        x=0.25×0.25=0.0625
        
    - nn-কে আবার অর্ধেক করি: n=1//2=0।
        
        n=1//2=0
        
4. **লুপ শেষ:** n=0n=0 হওয়ায় লুপ শেষ হয়, এবং `ans = 0.125` হয়।

### আউটপুট

ফাংশনটি `ans` রিটার্ন করে, অর্থাৎ `0.125`। সুতরাং, `myPow(2, -3)` এর আউটপুট হবে `0.125`, যা সঠিক।

### সংক্ষেপে

- **নেগেটিভ nn** থাকলে, x=1/x এবং n=−n করি।
    
    x=1/x
    
    n=−n
    
- **Exponentiation by Squaring** ব্যবহার করে লুপের ভেতরে x কে স্কয়ার করি আর n কে অর্ধেক করি।
    
    x
    
    n
    
- যদি n বিজোড় হয়, তখন `ans`এ x গুণ করি।
    
    n
    
    x
    

### কেন এই পদ্ধতি কার্যকরী

এটি খুব দ্রুত কারণ প্রতি ধাপে nn অর্ধেকে নেমে আসে, যা আমাদের O(log⁡n)O(logn) সময়ে সমাধান করতে দেয়। nn-এর যেকোনো বড় মানের জন্য এটি অত্যন্ত কার্যকরী।
 * */ 